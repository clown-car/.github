name: Support Repo Lifecycle Manager

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch: {}

jobs:
  cleanup-repos:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Cleanup stale support repositories
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SRLM_TOKEN }}
          script: |
            const INACTIVITY_THRESHOLD_DAYS = 14;
            const REPO_NAME_PATTERN = /^\d{7}/;
            const org = '${{ vars.SRLM_ORG }}';
            const isManualRun = '${{ github.event_name }}' === 'workflow_dispatch';
            
            // Validate organization variable
            if (!org || org.trim() === '') {
              core.setFailed('‚ùå SRLM_ORG variable is not set. Please add it in repository settings > Variables.');
              return;
            }
            
            // Calculate cutoff date (14 days ago from now)
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - INACTIVITY_THRESHOLD_DAYS);
            
            console.log(`üîç Scanning organization: ${org}`);
            console.log(`üöÄ Run type: ${isManualRun ? 'MANUAL (delete all matching repos)' : 'SCHEDULED (check activity)'}`);
            if (!isManualRun) {
              console.log(`üìÖ Cutoff date: ${cutoffDate.toISOString()}`);
            }
            console.log(`üéØ Target pattern: Repository names starting with 7 digits`);
            console.log('‚îÄ'.repeat(80));
            
            // Fetch all repositories in the organization
            let repos;
            try {
              repos = await github.paginate(github.rest.repos.listForOrg, {
                org: org,
                type: 'all',
                per_page: 100
              });
            } catch (error) {
              core.setFailed(`‚ùå Failed to access organization "${org}". Error: ${error.message}\n\nPossible causes:\n- Organization name is incorrect\n- Token doesn't have access to this organization\n- Token lacks required permissions (Administration: Read)`);
              return;
            }
            
            console.log(`üì¶ Found ${repos.length} total repositories in ${org}`);
            
            // Filter repos matching the naming pattern
            const targetRepos = repos.filter(repo => REPO_NAME_PATTERN.test(repo.name));
            console.log(`üéØ Found ${targetRepos.length} repositories matching pattern`);
            console.log('‚îÄ'.repeat(80));
            
            let deletedCount = 0;
            let skippedCount = 0;
            
            for (const repo of targetRepos) {
              console.log(`\nüîé Checking: ${repo.name}`);
              
              try {
                let shouldDelete = false;
                let lastActivityDate = null;
                let activityType = null;
                
                if (isManualRun) {
                  // Manual run: delete all matching repos without checking activity
                  console.log(`  üî• MANUAL RUN - Deleting without activity check`);
                  shouldDelete = true;
                  lastActivityDate = repo.pushed_at || repo.updated_at || 'N/A';
                } else {
                  // Scheduled run: check for activity
                  let hasRecentActivity = false;
                  
                  // 1. Check commits
                  try {
                    const commits = await github.rest.repos.listCommits({
                      owner: org,
                      repo: repo.name,
                      since: cutoffDate.toISOString(),
                      per_page: 1
                    });
                    
                    if (commits.data.length > 0) {
                      hasRecentActivity = true;
                      lastActivityDate = commits.data[0].commit.committer.date;
                      activityType = 'commit';
                    }
                  } catch (error) {
                    // Empty repo or no commits - continue checking other activity
                    console.log(`  ‚ÑπÔ∏è  No commits found (may be empty repo)`);
                  }
                  
                  // 2. Check issues (comments, labels, state changes)
                  if (!hasRecentActivity) {
                    try {
                      const issues = await github.rest.issues.listForRepo({
                        owner: org,
                        repo: repo.name,
                        state: 'all',
                        since: cutoffDate.toISOString(),
                        per_page: 1
                      });
                      
                      if (issues.data.length > 0) {
                        hasRecentActivity = true;
                        lastActivityDate = issues.data[0].updated_at;
                        activityType = 'issue';
                      }
                    } catch (error) {
                      console.log(`  ‚ÑπÔ∏è  Could not check issues: ${error.message}`);
                    }
                  }
                  
                  // 3. Check pull requests
                  if (!hasRecentActivity) {
                    try {
                      const pulls = await github.rest.pulls.list({
                        owner: org,
                        repo: repo.name,
                        state: 'all',
                        sort: 'updated',
                        direction: 'desc',
                        per_page: 100
                      });
                      
                      // Check if any PR was updated after cutoff
                      const recentPRs = pulls.data.filter(pr => {
                        const updatedAt = new Date(pr.updated_at);
                        return updatedAt > cutoffDate;
                      });
                      
                      if (recentPRs.length > 0) {
                        hasRecentActivity = true;
                        lastActivityDate = recentPRs[0].updated_at;
                        activityType = 'pull request';
                      }
                    } catch (error) {
                      console.log(`  ‚ÑπÔ∏è  Could not check pull requests: ${error.message}`);
                    }
                  }
                  
                  // Determine last activity from repo metadata if no specific activity found
                  if (!lastActivityDate) {
                    lastActivityDate = repo.pushed_at || repo.updated_at;
                  }
                  
                  const daysSinceActivity = Math.floor(
                    (new Date() - new Date(lastActivityDate)) / (1000 * 60 * 60 * 24)
                  );
                  
                  if (hasRecentActivity) {
                    console.log(`  ‚úÖ ACTIVE - Last ${activityType}: ${lastActivityDate} (${daysSinceActivity} days ago)`);
                    shouldDelete = false;
                  } else {
                    console.log(`  ‚ùå INACTIVE - Last activity: ${lastActivityDate} (${daysSinceActivity} days ago)`);
                    shouldDelete = true;
                  }
                }
                
                if (shouldDelete) {
                  console.log(`  üóëÔ∏è  Deleting repository...`);
                  
                  await github.rest.repos.delete({
                    owner: org,
                    repo: repo.name
                  });
                  
                  console.log(`  ‚úì Deleted successfully`);
                  deletedCount++;
                } else {
                  skippedCount++;
                }
                
              } catch (error) {
                console.error(`  ‚ö†Ô∏è  Error processing ${repo.name}: ${error.message}`);
                skippedCount++;
              }
            }
            
            console.log('\n' + '‚ïê'.repeat(80));
            console.log('üìä SUMMARY');
            console.log('‚ïê'.repeat(80));
            console.log(`‚úÖ Active repositories: ${skippedCount}`);
            console.log(`üóëÔ∏è  Deleted repositories: ${deletedCount}`);
            console.log(`üì¶ Total checked: ${targetRepos.length}`);
            console.log('‚ïê'.repeat(80));
            
            // Create job summary
            const summaryTable = [
              [{data: 'Metric', header: true}, {data: 'Count', header: true}],
              ['Run Type', isManualRun ? 'Manual' : 'Scheduled'],
              ['Organization', org],
              ['Total Repositories Scanned', repos.length.toString()],
              ['Matching Name Pattern', targetRepos.length.toString()],
              ['Active (Preserved)', skippedCount.toString()],
              ['Inactive (Deleted)', deletedCount.toString()]
            ];
            
            if (!isManualRun) {
              summaryTable.push(['Inactivity Threshold', `${INACTIVITY_THRESHOLD_DAYS} days`]);
            }
            
            await core.summary
              .addHeading('Support Repo Lifecycle Manager - Cleanup Report')
              .addTable(summaryTable)
              .write();
